use crate::ast::*;
use std::fmt::Write;
use thiserror::Error;

#[derive(Debug, Error)]
pub enum CodegenError {
    #[error("Code generation failed: {0}")]
    GenerationFailed(String),
}

pub struct Generator {
    output: String,
    indent_level: usize,
}

impl Generator {
    fn new() -> Self {
        Self {
            output: String::new(),
            indent_level: 0,
        }
    }

    fn indent(&mut self) {
        self.indent_level += 1;
    }

    fn dedent(&mut self) {
        self.indent_level = self.indent_level.saturating_sub(1);
    }

    fn write_indent(&mut self) {
        for _ in 0..self.indent_level {
            self.output.push_str("  ");
        }
    }

    fn write_line(&mut self, line: &str) {
        if !line.is_empty() {
            self.write_indent();
            self.output.push_str(line);
        }
        self.output.push('\n');
    }

    fn write(&mut self, s: &str) {
        self.output.push_str(s);
    }

    fn generate_program(&mut self, program: &Program) -> Result<(), CodegenError> {
        self.write_line("-- Generated by Rico8");
        self.write_line("-- Pico-8 API functions are available natively");
        self.write_line("");

        for item in &program.items {
            self.generate_item(item)?;
            self.write_line("");
        }

        Ok(())
    }

    fn generate_item(&mut self, item: &Item) -> Result<(), CodegenError> {
        match item {
            Item::Struct(s) => self.generate_struct(s),
            Item::Enum(e) => self.generate_enum(e),
            Item::Trait(t) => self.generate_trait(t),
            Item::Impl(i) => self.generate_impl(i),
            Item::Function(f) => self.generate_function(f),
            Item::Const(c) => self.generate_const(c),
            Item::Global(stmt) => {
                // Generate global variable declaration (without 'local' keyword).
                match stmt {
                    Statement::Let(let_stmt) => {
                        self.write(&format!("{} = ", let_stmt.name));
                        if let Some(value) = &let_stmt.value {
                            self.generate_expr(value)?;
                        } else {
                            self.write("nil");
                        }
                        self.write_line("");
                    }
                    _ => self.generate_statement(stmt)?,
                }
                Ok(())
            }
        }
    }

    fn generate_struct(&mut self, s: &Struct) -> Result<(), CodegenError> {
        self.write_line(&format!("-- struct {}", s.name));
        // Create the struct as a table to hold methods.
        self.write_line(&format!("{} = {{}}", s.name));

        Ok(())
    }

    fn generate_enum(&mut self, e: &Enum) -> Result<(), CodegenError> {
        self.write_line(&format!("-- enum {}", e.name));

        for variant in &e.variants {
            match &variant.fields {
                VariantFields::Unit => {
                    self.write_line(&format!("{} = {{", variant.name));
                    self.indent();
                    self.write_line(&format!("tag = \"{}\"", variant.name));
                    self.dedent();
                    self.write_line("}");
                }
                VariantFields::Tuple(types) => {
                    self.write_line(&format!("function {}(...)", variant.name));
                    self.indent();
                    self.write_line("local args = {...}");
                    self.write_line("return {");
                    self.indent();
                    self.write_line(&format!("tag = \"{}\",", variant.name));
                    for i in 0..types.len() {
                        self.write_line(&format!("_{} = args[{}],", i, i + 1));
                    }
                    self.dedent();
                    self.write_line("}");
                    self.dedent();
                    self.write_line("end");
                }
                VariantFields::Named(fields) => {
                    self.write(&format!("function {}(", variant.name));
                    for (i, field) in fields.iter().enumerate() {
                        self.write(&field.name);
                        if i < fields.len() - 1 {
                            self.write(", ");
                        }
                    }
                    self.write_line(")");
                    self.indent();
                    self.write_line("return {");
                    self.indent();
                    self.write_line(&format!("tag = \"{}\",", variant.name));
                    for field in fields {
                        self.write_line(&format!("{} = {},", field.name, field.name));
                    }
                    self.dedent();
                    self.write_line("}");
                    self.dedent();
                    self.write_line("end");
                }
            }
        }

        Ok(())
    }

    fn generate_trait(&mut self, t: &Trait) -> Result<(), CodegenError> {
        self.write_line(&format!("-- trait {}", t.name));
        self.write_line(&format!("{} = {{}}", t.name));

        for method in &t.methods {
            if let Some(body) = &method.body {
                self.write(&format!("{}.{} = function(", t.name, method.name));
                self.generate_params(&method.params)?;
                self.write_line(")");
                self.generate_block(body)?;
                self.write_line("end");
            }
        }

        Ok(())
    }

    fn generate_impl(&mut self, i: &Impl) -> Result<(), CodegenError> {
        let target_name = self.type_to_string(&i.target_type);

        if let Some(trait_name) = &i.trait_name {
            self.write_line(&format!("-- impl {} for {}", trait_name, target_name));
        } else {
            self.write_line(&format!("-- impl {}", target_name));
        }

        // First, check if there's a new() method and modify it to set metatable
        let has_new = i.methods.iter().any(|m| m.name == "new");

        for method in &i.methods {
            self.write(&format!("function {}:{}", target_name, method.name));
            self.write("(");

            let non_self_params: Vec<_> = method.params.iter().filter(|p| !p.is_self).collect();

            for (i, param) in non_self_params.iter().enumerate() {
                self.write(&param.name);
                if i < non_self_params.len() - 1 {
                    self.write(", ");
                }
            }

            self.write_line(")");

            // If this is a new() method, we need to set the metatable
            if method.name == "new" {
                // Generate the body but capture any return statements
                self.write_line("  local obj");
                for stmt in &method.body.statements {
                    if let Statement::Return(Some(expr)) = stmt {
                        // Instead of returning directly, assign to obj
                        self.write_indent();
                        self.write("  obj = ");
                        self.generate_expr(expr)?;
                        self.write_line("");
                    } else {
                        self.generate_statement(stmt)?;
                    }
                }
                self.write_indent();
                self.write_line(&format!(
                    "  setmetatable(obj, {{__index = {}}})",
                    target_name
                ));
                self.write_indent();
                self.write_line("  return obj");
            } else {
                self.generate_block(&method.body)?;
            }

            self.write_line("end");
        }

        Ok(())
    }

    fn generate_function(&mut self, f: &Function) -> Result<(), CodegenError> {
        self.write(&format!("function {}", f.name));
        self.write("(");
        self.generate_params(&f.params)?;
        self.write_line(")");
        self.generate_block(&f.body)?;
        self.write_line("end");

        Ok(())
    }

    fn generate_const(&mut self, c: &Const) -> Result<(), CodegenError> {
        self.write(&format!("{} = ", c.name));
        self.generate_expr(&c.value)?;
        self.write_line("");
        Ok(())
    }

    fn generate_params(&mut self, params: &[Param]) -> Result<(), CodegenError> {
        for (i, param) in params.iter().enumerate() {
            if !param.is_self {
                self.write(&param.name);
                if i < params.len() - 1 {
                    self.write(", ");
                }
            }
        }
        Ok(())
    }

    fn generate_block(&mut self, block: &Block) -> Result<(), CodegenError> {
        self.indent();
        for statement in &block.statements {
            self.generate_statement(statement)?;
        }
        self.dedent();
        Ok(())
    }

    fn generate_statement(&mut self, stmt: &Statement) -> Result<(), CodegenError> {
        match stmt {
            Statement::Let(let_stmt) => {
                self.write_indent();
                self.write(&format!("local {} = ", let_stmt.name));
                if let Some(value) = &let_stmt.value {
                    self.generate_expr(value)?;
                } else {
                    self.write("nil");
                }
                self.write_line("");
            }
            Statement::Assign(lhs, rhs) => {
                self.write_indent();
                self.generate_expr(lhs)?;
                self.write(" = ");
                self.generate_expr(rhs)?;
                self.write_line("");
            }
            Statement::Expr(expr) => {
                self.write_indent();
                self.generate_expr(expr)?;
                self.write_line("");
            }
            Statement::Return(expr) => {
                self.write_indent();
                self.write("return");
                if let Some(expr) = expr {
                    self.write(" ");
                    self.generate_expr(expr)?;
                }
                self.write_line("");
            }
            Statement::If(if_stmt) => {
                self.write_indent();
                self.write("if ");
                self.generate_expr(&if_stmt.condition)?;
                self.write_line(" then");
                self.generate_block(&if_stmt.then_branch)?;
                if let Some(else_branch) = &if_stmt.else_branch {
                    self.write_line("else");
                    self.generate_block(else_branch)?;
                }
                self.write_line("end");
            }
            Statement::While(while_stmt) => {
                self.write_indent();
                self.write("while ");
                self.generate_expr(&while_stmt.condition)?;
                self.write_line(" do");
                self.generate_block(&while_stmt.body)?;
                self.write_line("end");
            }
            Statement::For(for_stmt) => {
                self.write_indent();
                // Check if iterator is a range (numeric for loop) or table (generic for loop)
                match &for_stmt.iter {
                    Expr::Range(_, _) => {
                        // Numeric for loop: for var=start,end do
                        self.write(&format!("for {}=", for_stmt.var));
                        self.generate_expr(&for_stmt.iter)?;
                    }
                    _ => {
                        // Generic for loop: for var in pairs(iter) do
                        // Using pairs() for tables (could use ipairs() for arrays)
                        self.write(&format!("for _,{} in pairs(", for_stmt.var));
                        self.generate_expr(&for_stmt.iter)?;
                        self.write(")");
                    }
                }
                self.write_line(" do");
                self.generate_block(&for_stmt.body)?;
                self.write_line("end");
            }
            Statement::Match(match_stmt) => {
                self.generate_match_statement(match_stmt)?;
            }
        }
        Ok(())
    }

    fn generate_match_statement(
        &mut self,
        match_stmt: &MatchStatement,
    ) -> Result<(), CodegenError> {
        self.write_indent();
        self.write("local __match = ");
        self.generate_expr(&match_stmt.expr)?;
        self.write_line("");

        for (i, arm) in match_stmt.arms.iter().enumerate() {
            if i == 0 {
                self.write_indent();
                self.write("if ");
            } else {
                self.write_indent();
                self.write("elseif ");
            }

            self.generate_pattern_condition(&arm.pattern, "__match")?;
            self.write_line(" then");
            self.indent();
            self.write_indent();
            self.generate_expr(&arm.body)?;
            self.write_line("");
            self.dedent();
        }

        self.write_line("end");
        Ok(())
    }

    fn generate_pattern_condition(
        &mut self,
        pattern: &Pattern,
        var: &str,
    ) -> Result<(), CodegenError> {
        match pattern {
            Pattern::Wildcard => self.write("true"),
            Pattern::Ident(_) => self.write("true"),
            Pattern::Literal(lit) => {
                self.write(&format!("{} == ", var));
                self.generate_literal(lit)?;
            }
            Pattern::Enum(_, variant, _) => {
                self.write(&format!("{}.tag == \"{}\"", var, variant));
            }
            Pattern::Struct(_, _) | Pattern::Tuple(_) => {
                self.write("true");
            }
        }
        Ok(())
    }

    fn generate_expr(&mut self, expr: &Expr) -> Result<(), CodegenError> {
        match expr {
            Expr::Literal(lit) => self.generate_literal(lit)?,
            Expr::Ident(name) => {
                // Convert Rust-style paths to Lua-style.
                let lua_name = if name.contains("::") {
                    // Split on :: to handle different cases
                    if let Some(sep_pos) = name.find("::") {
                        let prefix = &name[..sep_pos];
                        let suffix = &name[sep_pos + 2..];

                        // Check if this looks like an enum variant (starts with uppercase)
                        // Enums are just global variables, not namespaced
                        if prefix.chars().next().map_or(false, |c| c.is_uppercase())
                            && suffix.chars().next().map_or(false, |c| c.is_uppercase())
                        {
                            // Enum variant - just use the variant name
                            suffix.to_string()
                        } else {
                            // Method/other - use dot notation
                            name.replace("::", ".")
                        }
                    } else {
                        name.clone()
                    }
                } else {
                    name.clone()
                };
                self.write(&lua_name)
            }
            Expr::Binary(op, left, right) => {
                // Check if this is string concatenation (+ with string operands)
                let is_string_concat = matches!(op, BinaryOp::Add)
                    && (Self::is_string_expr(left) || Self::is_string_expr(right));

                self.write("(");
                self.generate_expr(left)?;
                self.write(" ");

                if is_string_concat {
                    self.write(".."); // Lua string concatenation
                } else {
                    self.write(match op {
                        BinaryOp::Add => "+",
                        BinaryOp::Sub => "-",
                        BinaryOp::Mul => "*",
                        BinaryOp::Div => "/",
                        BinaryOp::Mod => "%",
                        BinaryOp::And => "and",
                        BinaryOp::Or => "or",
                        BinaryOp::Eq => "==",
                        BinaryOp::Ne => "~=",
                        BinaryOp::Lt => "<",
                        BinaryOp::Le => "<=",
                        BinaryOp::Gt => ">",
                        BinaryOp::Ge => ">=",
                        BinaryOp::BitAnd => "&",
                        BinaryOp::BitOr => "|",
                        BinaryOp::BitXor => "^^",
                        BinaryOp::Shl => "<<",
                        BinaryOp::Shr => ">>",
                    });
                }

                self.write(" ");
                self.generate_expr(right)?;
                self.write(")");
            }
            Expr::Unary(op, expr) => {
                self.write(match op {
                    UnaryOp::Not => "not ",
                    UnaryOp::Neg => "-",
                });
                self.generate_expr(expr)?;
            }
            Expr::Call(func, args) => {
                // Check if this is a constructor/method call pattern (e.g., Player::new)
                let func_name = if let Expr::Ident(name) = &**func {
                    if name.contains("::") {
                        // Split on :: to handle Rust-style paths.
                        if let Some(sep_pos) = name.find("::") {
                            let obj = &name[..sep_pos];
                            let method = &name[sep_pos + 2..];
                            // Constructor patterns should use : for method syntax.
                            if method == "new"
                                || method.starts_with("from_")
                                || obj.chars().next().map_or(false, |c| c.is_uppercase())
                            {
                                self.write(obj);
                                self.write(":");
                                self.write(method);
                            } else {
                                // Enum variants use dot notation.
                                self.write(obj);
                                self.write(".");
                                self.write(method);
                            }
                        } else {
                            self.write(name);
                        }
                        Some(name.clone())
                    } else {
                        self.write(name);
                        Some(name.clone())
                    }
                } else {
                    self.generate_expr(func)?;
                    None
                };

                self.write("(");

                // Generate arguments, filtering out trailing None values (they become nil which is optional)
                let mut args_to_write = Vec::new();
                for arg in args.iter() {
                    args_to_write.push(arg);
                }

                // Remove trailing None arguments
                while args_to_write
                    .last()
                    .map_or(false, |arg| matches!(arg, Expr::None))
                {
                    args_to_write.pop();
                }

                for (i, arg) in args_to_write.iter().enumerate() {
                    self.generate_expr(arg)?;
                    if i < args_to_write.len() - 1 {
                        self.write(", ");
                    }
                }
                self.write(")");
            }
            Expr::MethodCall(obj, method, args) => {
                self.generate_expr(obj)?;
                self.write(&format!(":{}", method));
                self.write("(");
                for (i, arg) in args.iter().enumerate() {
                    self.generate_expr(arg)?;
                    if i < args.len() - 1 {
                        self.write(", ");
                    }
                }
                self.write(")");
            }
            Expr::Field(obj, field) => {
                self.generate_expr(obj)?;
                self.write(&format!(".{}", field));
            }
            Expr::Index(obj, index) => {
                self.generate_expr(obj)?;
                self.write("[");
                self.generate_expr(index)?;
                self.write("]");
            }
            Expr::Struct(name, fields) => {
                // Generate inline table literal for struct construction
                self.write("{");
                for (i, (field_name, value)) in fields.iter().enumerate() {
                    self.write(&format!("{} = ", field_name));
                    self.generate_expr(value)?;
                    if i < fields.len() - 1 {
                        self.write(", ");
                    }
                }
                self.write("}");
            }
            Expr::Array(elements) => {
                self.write("{");
                for (i, elem) in elements.iter().enumerate() {
                    self.generate_expr(elem)?;
                    if i < elements.len() - 1 {
                        self.write(", ");
                    }
                }
                self.write("}");
            }
            Expr::Tuple(elements) => {
                self.write("{");
                for (i, elem) in elements.iter().enumerate() {
                    self.generate_expr(elem)?;
                    if i < elements.len() - 1 {
                        self.write(", ");
                    }
                }
                self.write("}");
            }
            Expr::Block(block) => {
                self.write_line("(function()");
                self.generate_block(block)?;
                self.write_indent();
                self.write("end)()");
            }
            Expr::If(if_stmt) => {
                self.write("(");
                self.generate_expr(&if_stmt.condition)?;
                self.write(" and ");
                if !if_stmt.then_branch.statements.is_empty() {
                    if let Statement::Expr(expr) = &if_stmt.then_branch.statements[0] {
                        self.generate_expr(expr)?;
                    }
                }
                if let Some(else_branch) = &if_stmt.else_branch {
                    self.write(" or ");
                    if !else_branch.statements.is_empty() {
                        if let Statement::Expr(expr) = &else_branch.statements[0] {
                            self.generate_expr(expr)?;
                        }
                    }
                }
                self.write(")");
            }
            Expr::Match(match_stmt) => {
                self.write("(function()\n");
                self.indent();
                self.generate_match_statement(match_stmt)?;
                self.dedent();
                self.write_indent();
                self.write("end)()");
            }
            Expr::Range(start, end) => {
                if let Some(start) = start {
                    self.generate_expr(start)?;
                } else {
                    self.write("1");
                }
                self.write(",");
                if let Some(end) = end {
                    self.generate_expr(end)?;
                } else {
                    self.write("#t");
                }
            }
            Expr::None => {
                // In Lua, we represent None as nil
                self.write("nil");
            }
            Expr::Some(value) => {
                // In Lua, Some(value) is just the value itself
                self.generate_expr(value)?;
            }
        }
        Ok(())
    }

    fn generate_literal(&mut self, lit: &Literal) -> Result<(), CodegenError> {
        match lit {
            Literal::Int(n) => self.write(&n.to_string()),
            Literal::Float(f) => self.write(&f.to_string()),
            Literal::Bool(b) => self.write(if *b { "true" } else { "false" }),
            Literal::String(s) => self.write(&format!("\"{}\"", s.replace('\"', "\\\""))),
            Literal::Char(c) => self.write(&format!("\"{}\"", c)),
        }
        Ok(())
    }

    fn type_to_string(&self, ty: &Type) -> String {
        match ty {
            Type::Path(name) => name.clone(),
            Type::Generic(name, _) => name.clone(),
            Type::Reference(inner, _) => self.type_to_string(inner),
            Type::Array(_, _) => "array".to_string(),
            Type::Tuple(_) => "tuple".to_string(),
        }
    }

    fn is_string_expr(expr: &Expr) -> bool {
        match expr {
            Expr::Literal(Literal::String(_)) => true,
            Expr::Binary(BinaryOp::Add, left, right) => {
                // Recursive check for nested string concatenation
                Self::is_string_expr(left) || Self::is_string_expr(right)
            }
            Expr::Call(func, _) => {
                // Check if it's a call to tostr or other string-returning functions
                if let Expr::Ident(name) = &**func {
                    name == "tostr" || name == "tostring" || name == "str"
                } else {
                    false
                }
            }
            _ => false,
        }
    }
}

pub fn generate(program: Program) -> Result<String, CodegenError> {
    let mut generator = Generator::new();
    generator.generate_program(&program)?;
    Ok(generator.output)
}
