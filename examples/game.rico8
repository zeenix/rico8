// A modular example game in Rico8
// Demonstrates imports and Pico-8 API usage with Rico8's type safety

use player::{Player, Drawable, Updatable};
use collectibles::{Coin, Powerup};

enum GameState {
    Title,
    Playing,
    GameOver,
    Victory,
}

struct Game {
    state: GameState,
    player: Player,
    coins: Array<Coin>,
    powerup: Powerup,
    score: i32,
    time: i32,
}

// Global game instance.
let mut game: Game;

fn _init() {
    // Initialize the game.
    game = Game {
        state: GameState::Title,
        player: Player::new(),
        coins: [],
        powerup: Powerup::new(60, 60),
        score: 0,
        time: 0,
    };

    // Setup level.
    setup_level();

    // Initialize music.
    music(0, 0, 0);
}

fn setup_level() {
    // Clear coins.
    game.coins = [];

    // Place random coins around the screen.
    for i in 0..10 {
        let x = 10 + (i * 10) % 100;
        let y = 20 + (i * 7) % 80;
        add(game.coins, Coin::new(x, y), None);
    }

    // Reset powerup
    game.powerup = Powerup::new(60, 60);
}

fn _update() {
    match game.state {
        GameState::Title => {
            if btnp(4, 0) || btnp(5, 0) {
                game.state = GameState::Playing;
                game.score = 0;
                game.time = 0;
                game.player = Player::new();
                setup_level();
            }
        },
        GameState::Playing => {
            game.time = game.time + 1;

            // Update player using trait method.
            game.player.update();

            // Update powerup using trait method.
            game.powerup.update();

            // Check powerup collection.
            game.powerup.check_collection(&game.player);

            // Update coins and handle scoring.
            for coin in game.coins {
                if coin.update(&game.player) {
                    // Coin was just collected
                    if game.powerup.active {
                        game.score = game.score + 20;  // Double points
                    } else {
                        game.score = game.score + 10;
                    }
                }
            }

            // Check victory.
            let mut all_collected = true;
            let mut has_coins = false;
            for coin in game.coins {
                has_coins = true;
                if !coin.collected {
                    all_collected = false;
                }
            }

            if all_collected && has_coins {
                game.state = GameState::Victory;
                music(-1, 0, 0);
                sfx(4, -1, 0, 0);
            }
        },
        GameState::GameOver => {
            if btnp(4, 0) || btnp(5, 0) {
                game.state = GameState::Title;
                music(0, 0, 0);
            }
        },
        GameState::Victory => {
            if btnp(4, 0) || btnp(5, 0) {
                game.state = GameState::Title;
                music(0, 0, 0);
            }
        },
    }
}

fn _draw() {
    cls(1);  // Clear with dark blue.

    match game.state {
        GameState::Title => {
            // Title screen.
            print("RICO8 EXAMPLE", 24, 40, 7);
            print("COLLECT ALL COINS!", 20, 50, 10);
            print("ARROW KEYS TO MOVE", 20, 64, 6);
            print("PRESS O TO START", 24, 88, 11);
        },
        GameState::Playing => {
            // Clear screen with dark blue.
            cls(1);

            // Draw coins using trait method.
            for coin in game.coins {
                coin.draw();
            }

            // Draw powerup using trait method.
            game.powerup.draw();

            // Draw player using trait method.
            game.player.draw();

            // Draw HUD.
            rectfill(0, 0, 127, 7, 0);
            print("SCORE: " + tostr(game.score, false), 2, 1, 7);
            print("TIME: " + tostr(flr(game.time / 30), false) + "s", 80, 1, 7);

            // Show powerup status.
            if game.powerup.active {
                print("2X!", 60, 1, 8);
            }
        },
        GameState::GameOver => {
            rectfill(20, 48, 107, 80, 0);
            rect(20, 48, 107, 80, 8);
            print("GAME OVER", 44, 56, 8);
            print("SCORE: " + tostr(game.score, false), 36, 66, 7);
            print("PRESS O TO RETRY", 24, 96, 11);
        },
        GameState::Victory => {
            rectfill(20, 48, 107, 80, 0);
            rect(20, 48, 107, 80, 11);
            print("VICTORY!", 48, 56, 11);
            print("SCORE: " + tostr(game.score, false), 36, 66, 7);
            print("TIME: " + tostr(flr(game.time / 30), false) + "s", 40, 74, 7);
            print("PRESS O TO MENU", 28, 96, 10);
        },
    }
}